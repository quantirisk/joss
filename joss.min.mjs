// Copyright (c) 2021 Quantitative Risk Solutions PLT (201604001668)
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 
"use strict";const endian=getEndianness(),encoders={Object:encodeCollect,Array:encodeCollect,Map:encodeCollect,Set:encodeCollect,DataView:encodeTypedArray,Int8Array:encodeTypedArray,Uint8Array:encodeTypedArray,Uint8ClampedArray:encodeTypedArray,Int16Array:encodeTypedArray,Uint16Array:encodeTypedArray,Int32Array:encodeTypedArray,Uint32Array:encodeTypedArray,Float32Array:encodeTypedArray,Float64Array:encodeTypedArray,BigInt64Array:encodeTypedArray,BigUint64Array:encodeTypedArray,Date:encodeDate,RegExp:encodeRegExp,ArrayBuffer:encodeString,SharedArrayBuffer:encodeString,Boolean:encodeBoolean,Number:encodeNumber,BigInt:encodeBigInt,String:encodeString},errors={hole:new Error("Encountered a hole in a sparse array"),ended:new Error("The serialized bytestream ended before the deserialization could complete successfully."),unused:new Error("The deserialization completed before the end of the serialized bytestream."),exceeded:new Error("The serialized bytestream exceeded the maximum acceptable length."),malformed:new Error("The serialized bytestream contained malformed byte sequences."),property:new Error("Encountered an undefined property of a collection."),collection:new Error("Encountered a collection in streaming mode.")};errors.ended.name="ERR_ENDED",errors.unused.name="ERR_UNUSED",errors.exceeded.name="ERR_EXCEEDED",errors.malformed.name="ERR_MALFORMED";export{encodeStatic as serialize,decodeStatic as deserialize,encodeStream as serializable,decodeStream as deserializable,decodeAsync as deserializing};function encodeStatic(c,b){const a={};if(b===void 0)b={};else if(typeof b!="object")throw new TypeError("The options parameter must be an object.");if(b.hasOwnProperty("endian")===!1)a.endian=endian;else if(b.endian==="LE"||b.endian==="BE")a.endian=b.endian;else throw new RangeError('The endian option must be either "LE" or "BE".');return a.bytes=[],a.length=0,a.record=new Map,a.method="static",encodeData(a,c),concatBytes(a.bytes,a.length)}function encodeData(a,b){switch(typeof b){case"object":if(b!==null){const c=b.constructor.name,d=encoders[c];return d!==void 0?a.record.has(b)===!1?(a.record.set(b,a.length),d(a,b,c)):encodeReference(a,b):appendBytes(a,Uint8Array.of(13))}else return appendBytes(a,Uint8Array.of(0));case"undefined":return appendBytes(a,Uint8Array.of(1));case"boolean":return encodeBoolean(a,b);case"number":return encodeNumber(a,b);case"bigint":return encodeBigInt(a,b);case"string":return encodeString(a,b);default:appendBytes(a,Uint8Array.of(13))}}function encodeBoolean(a,b,c){c===void 0?b===!0?appendBytes(a,Uint8Array.of(2)):appendBytes(a,Uint8Array.of(4)):b.valueOf()===!0?appendBytes(a,Uint8Array.of(3)):appendBytes(a,Uint8Array.of(5))}function encodeNumber(b,e,f){let d,c,a;if(d=1<<5,f===void 0)if(a=e,isFinite(a));else return a===1/0?appendBytes(b,Uint8Array.of(6)):a===-(1/0)?appendBytes(b,Uint8Array.of(8)):appendBytes(b,Uint8Array.of(10));else if(a=e.valueOf(),isFinite(a))d|=1<<4;else return a===1/0?appendBytes(b,Uint8Array.of(7)):a===-(1/0)?appendBytes(b,Uint8Array.of(9)):appendBytes(b,Uint8Array.of(11));Math.floor(a)===a&&Math.abs(a)<=Number.MAX_SAFE_INTEGER?((a<0||a===0&&1/a===-(1/0))&&(d|=1<<3),c=encodeUInt(Math.abs(a))):(c=new Uint8Array(new ArrayBuffer(8)),new DataView(c.buffer,c.byteOffset,c.byteOffset+c.length).setFloat64(0,a,!0)),appendBytes(b,Uint8Array.of(d|c.length-1)),appendBytes(b,c)}function encodeBigInt(d,e,g){let b,c,a;b=2<<5,g===void 0?a=e:(a=e.valueOf(),b|=1<<4),a>=0?c=encodeBigUInt(a):(b|=1<<3,c=encodeBigUInt(-a));const f=encodeUInt(c.length);appendBytes(d,Uint8Array.of(b|f.length-1)),appendBytes(d,f),appendBytes(d,c)}function encodeString(e,c,d,g,h){let b,a;b=3<<5,d===void 0?a=encodeUTF8(c):d==="String"?(b|=1<<3,a=encodeUTF8(c.valueOf())):(d==="ArrayBuffer"?b|=2<<3:b|=3<<3,a=new Uint8Array(c,g||0,h||c.byteLength));const f=encodeUInt(a.length);appendBytes(e,Uint8Array.of(b|f.length-1)),appendBytes(e,f),appendBytes(e,a)}function encodeCollect(a,b,d){if(a.method==="stream")throw errors.collection;let c;if(c=4<<5,d==="Array"){const d=encodeUInt(b.length),e=analyzeArray(b);if(e.nslot!==void 0){c=5<<5;const f=e.nslot,g=encodeUInt(f);appendBytes(a,Uint8Array.of(c|0<<4|d.length-1<<2|g.length-1)),appendBytes(a,d),appendBytes(a,g);for(let c=0;c<f;c+=1)b.hasOwnProperty(c)?encodeData(a,b[c]):appendBytes(a,Uint8Array.of(12))}else if(e.nelement!==void 0){c=5<<5;const f=encodeUInt(e.nelement);appendBytes(a,Uint8Array.of(c|1<<4|d.length-1<<2|f.length-1)),appendBytes(a,d),appendBytes(a,f),b.forEach(function(b,c){encodeData(a,c),encodeData(a,b)})}else{const e=encodeUInt(b.length);appendBytes(a,Uint8Array.of(c|d.length-1)),appendBytes(a,d),b.forEach(function(b){encodeData(a,b)})}}else if(d==="Object"){{const d=encodeUInt(Object.keys(b).length);appendBytes(a,Uint8Array.of(c|1<<3|d.length-1)),appendBytes(a,d);for(let c in b)b.hasOwnProperty(c)&&(encodeData(a,c),encodeData(a,b[c]))}}else if(d==="Map"){const d=encodeUInt(b.size);appendBytes(a,Uint8Array.of(c|2<<3|d.length-1)),appendBytes(a,d),b.forEach(function(b,c){encodeData(a,c),encodeData(a,b)})}else{const d=encodeUInt(b.size);appendBytes(a,Uint8Array.of(c|3<<3|d.length-1)),appendBytes(a,d),b.forEach(function(b){encodeData(a,b)})}}function encodeTypedArray(c,b,g){let d,a,e,f;if(d=6<<5,c.endian==="BE"&&(d|=1<<4),c.endian!==endian&&b.BYTES_PER_ELEMENT>1){switch(a=b.buffer.slice(b.byteOffset,b.byteOffset+b.byteLength),b.BYTES_PER_ELEMENT){case 2:a=swap16(a);break;case 4:a=swap32(a);break;case 8:a=swap64(a);break}e=0,f=a.byteLength}else a=b.buffer,e=b.byteOffset,f=b.byteLength;const h=["DataView","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];appendBytes(c,Uint8Array.of(d|h.indexOf(g))),c.record.has(a)===!1?(c.record.set(a,c.length),encodeString(c,a,a.constructor.name,e,f)):encodeReference(c,a)}function encodeDate(a,b){appendBytes(a,Uint8Array.of(14)),encodeData(a,b.valueOf())}function encodeRegExp(a,b){appendBytes(a,Uint8Array.of(15)),encodeData(a,b.toString())}function encodeReference(a,b){appendBytes(a,Uint8Array.of(29)),encodeNumber(a,a.record.get(b))}function encodeUInt(a){const b=[];while(a>255)b.push(a&255),a=Math.floor(a/256);return b.push(a),Uint8Array.from(b)}function encodeBigUInt(a){const b=[],d=BigInt(8),c=BigInt(255);while(a>c)b.push(Number(a&c)),a=a>>d;return b.push(Number(a)),Uint8Array.from(b)}function encodeUTF8(a){try{return(new TextEncoder).encode(a)}catch(e){let c=0;const b=[],d=a.length;while(c<d){let d=a.charCodeAt(c++);if(d<=127)b.push(d);else if(d<=2047)b.push(d>>6&31|192),b.push(d&63|128);else if(d<=55295||d>=57344&&d<=65535)b.push(d>>12&15|224),b.push(d>>6&63|128),b.push(d&63|128);else{const e=d,f=a.charCodeAt(c++);if(e<55296||e>56319)continue;if(f<56320||f>57343)continue;d=(e&1023)<<10|f&1023,d+=65536,b.push(d>>18&7|240),b.push(d>>12&63|128),b.push(d>>6&63|128),b.push(d&63|128)}}return Uint8Array.from(b)}}function encodeStream(j,c){const a={};if(c===void 0)c={};else if(typeof c!="object")throw new TypeError("The options parameter must be an object.");if(c.hasOwnProperty("endian")===!1)a.endian=endian;else if(c.endian==="LE"||c.endian==="BE")a.endian=c.endian;else throw new RangeError('The endian option must be either "LE" or "BE".');a.length=0,a.record=new Map,a.method="stream";const d=[],b=[],g=[],h=Symbol(),e=Symbol(),f=Symbol();return new ReadableStream({start:k,pull:l});function k(a){d.push(0),b.push({root:j}),g.push(i(b[0]))}function l(j){let k=0,c=b.length-1;for(a.bytes=[];k<16384&&c>=0;){const n=a.length,l=d[c],j=b[c],o=g[c],m=o.next();if(l===0){let b;b=4<<5;const d=j.constructor.name;if(d==="Array"){const c=encodeUInt(j.length);if(j.hasOwnProperty(e)){b=5<<5;const d=encodeUInt(j[e]);appendBytes(a,Uint8Array.of(b|0<<4|c.length-1<<2|d.length-1)),appendBytes(a,c),appendBytes(a,d)}else if(j.hasOwnProperty(f)){b=5<<5;const d=encodeUInt(j[f]);appendBytes(a,Uint8Array.of(b|1<<4|c.length-1<<2|d.length-1)),appendBytes(a,c),appendBytes(a,d)}else{const d=encodeUInt(j.length);appendBytes(a,Uint8Array.of(b|c.length-1)),appendBytes(a,c)}}else if(d==="Object"&&c!==0){const c=encodeUInt(j[h]);appendBytes(a,Uint8Array.of(b|1<<3|c.length-1)),appendBytes(a,c)}else if(d==="Map"){const c=encodeUInt(j.size);appendBytes(a,Uint8Array.of(b|2<<3|c.length-1)),appendBytes(a,c)}else if(d==="Set"){const c=encodeUInt(j.size);appendBytes(a,Uint8Array.of(b|3<<3|c.length-1)),appendBytes(a,c)}}if(m.done===!1){if(l!==2){const e=m.value,h=j.constructor.name;if(h==="Array"&&j.hasOwnProperty(f))encodeData(a,e);else if(h==="Object"&&c!==0)encodeData(a,e);else if(h==="Map")try{encodeData(a,e)}catch(a){if(a===errors.collection)d.push(0),b.push(e),g.push(i(e));else throw a}d[c]=2}else if(l===2){const f=m.value;if(f!==errors.hole)try{encodeData(a,f)}catch(a){if(a===errors.collection)d.push(0),b.push(f),g.push(i(f));else throw a}else j.hasOwnProperty(e)&&appendBytes(a,Uint8Array.of(12));d[c]=1}}else delete j[f],delete j[e],delete j[h],d.pop(),b.pop(),g.pop();k+=a.length-n,c=b.length-1}a.bytes.length!==0?j.enqueue(concatBytes(a.bytes)):c>=0?this.pull(j):j.close()}function i(a){let b,i,g,c;i="key";const d=a.constructor.name;if(d==="Array"){c=a.keys();const b=analyzeArray(a);b.nslot!==void 0?Object.defineProperty(a,e,{configurable:!0,value:b.nslot}):b.nelement!==void 0&&Object.defineProperty(a,f,{configurable:!0,value:b.nelement})}else d==="Object"?(c=Object.keys(a),Object.defineProperty(a,h,{configurable:!0,value:c.length}),g=-1):(d==="Map"||d==="Set")&&(c=a.keys());return{next:j};function j(){if(i==="key")if(i="value",g===void 0){let d=c.next();if(a.hasOwnProperty(f))while(a.hasOwnProperty(d.value)===!1&&d.done===!1)d=c.next();return d.done===!1?(b=d.value,a.hasOwnProperty(e)&&b>=a[e])?{value:void 0,done:!0}:{value:b,done:!1}:{value:void 0,done:!0}}else return g+=1,c[g]!==void 0?(b=c[g],{value:b,done:!1}):{value:void 0,done:!0};else if(i="key",d==="Array")return a.hasOwnProperty(b)?{value:a[b],done:!1}:{value:errors.hole,done:!1};else if(d==="Object")return{value:a[b],done:!1};else if(d==="Map")return{value:a.get(b),done:!1};else if(d==="Set")return{value:b,done:!1}}}}function decodeStatic(b){if(typeof b!="object"||b.constructor.name!=="Uint8Array")throw new TypeError("The bytes parameter must be a Uint8Array.");const a={};a.map=new Map,a.bytes=b,a.cursor=0,a.offset=0,a.method="static";const c=decodeData(a);if(a.cursor!==a.bytes.length)throw errors.unused;return c}function decodeData(a){const b=a.bytes[a.cursor];if(b===void 0)throw errors.ended;if(b<=13){let c;switch(a.cursor++,a.offset++,b){case 0:return null;case 1:return void 0;break;case 2:return!0;case 3:c=new Boolean(!0);break;case 4:return!1;case 5:c=new Boolean(!1);break;case 6:return 1/0;case 7:c=new Number(1/0);break;case 8:return-(1/0);case 9:c=new Number(-(1/0));break;case 10:return NaN;case 11:c=new Number(NaN);break;case 12:return errors.hole;case 13:return new ReferenceError}return a.map.set(a.offset-1,c),c}if(b<=31)switch(b){case 14:return decodeDate(a);case 15:return decodeRegExp(a);case 29:return decodeReference(a);default:throw errors.malformed}else switch(b>>5){case 1:return decodeNumber(a);case 2:return decodeBigInt(a);case 3:return decodeString(a);case 4:return decodeCollect(a);case 5:return decodeSparseArray(a);case 6:return decodeTypedArray(a);case 7:throw errors.malformed}}function decodeNumber(a){let b,c=a.cursor;const e=a.bytes[c++],d=(e&7)+1;if(c+d>a.bytes.length)throw errors.ended;if(d<8){if(d===7&&a.bytes[c+6]>31)throw errors.malformed;b=decodeUInt(a.bytes.subarray(c,c+=d)),(e>>3&1)===1&&(b*=-1)}else{const e=a.bytes.subarray(c,c+=d);b=new DataView(e.buffer,e.byteOffset,e.length).getFloat64(0,!0)}return(e>>4&1)===1&&(b=new Number(b),a.map.set(a.offset,b)),a.cursor+=d+1,a.offset+=d+1,b}function decodeBigInt(a){let c,b=a.cursor;const f=a.bytes[b++],d=(f&7)+1;if(b+d>a.bytes.length)throw errors.ended;const e=decodeUInt(a.bytes.subarray(b,b+=d));if(b+e>a.bytes.length)throw errors.ended;return c=decodeBigUInt(a.bytes.subarray(b,b+=e)),(f>>3&1)===1&&(c*=BigInt(-1)),(f>>4&1)===1&&(c=new Object(c),a.map.set(a.offset,c)),a.cursor+=d+e+1,a.offset+=d+e+1,c}function decodeString(a){let c,b=a.cursor;const f=a.bytes[b++],e=(f&7)+1;if(b+e>a.bytes.length)throw errors.ended;const d=decodeUInt(a.bytes.subarray(b,b+=e));if(b+d>a.bytes.length)throw errors.ended;switch(f>>3&3){case 0:c=decodeUTF8(a.bytes,b,b+=d);break;case 1:c=new String(decodeUTF8(a.bytes,b,b+=d)),a.map.set(a.offset,c);break;case 2:c=new ArrayBuffer(d),a.map.set(a.offset,c),new Uint8Array(c).set(a.bytes.subarray(b,b+=d));break;case 3:c=new SharedArrayBuffer(d),a.map.set(a.offset,c),new Uint8Array(c).set(a.bytes.subarray(b,b+=d))}return a.cursor+=e+d+1,a.offset+=e+d+1,c}function decodeCollect(a){if(a.method==="stream")throw errors.collection;let b,d=a.cursor;const f=a.bytes[d++],g=a.bytes.length,c=(f&7)+1;if(d+c>g)throw errors.ended;const e=decodeUInt(a.bytes.subarray(d,d+=c));switch(f>>3&3){case 0:b=[],a.map.set(a.offset,b),a.cursor+=c+1,a.offset+=c+1;for(let c=0;c<e;c+=1){if(isHoleByte(a))throw errors.malformed;b.push(decodeData(a))}return b;case 1:b={},a.map.set(a.offset,b),a.cursor+=c+1,a.offset+=c+1;for(let c=0;c<e;c+=1){if(isStringByte(a)===!1)throw errors.malformed;const d=decodeData(a);if(b.hasOwnProperty(d))throw errors.malformed;if(isHoleByte(a))throw errors.malformed;b[d]=decodeData(a)}return b;case 2:b=new Map,a.map.set(a.offset,b),a.cursor+=c+1,a.offset+=c+1;for(let c=0;c<e;c+=1){const d=decodeData(a);if(b.has(d))throw errors.malformed;if(isHoleByte(a))throw errors.malformed;b.set(d,decodeData(a))}return b;case 3:b=new Set,a.map.set(a.offset,b),a.cursor+=c+1,a.offset+=c+1;for(let c=0;c<e;c+=1){if(isHoleByte(a))throw errors.malformed;const d=decodeData(a);if(b.has(d))throw errors.malformed;b.add(d)}return b}}function decodeSparseArray(a){if(a.method==="stream")throw errors.collection;let b=a.cursor;const f=a.bytes[b++],g=a.bytes.length,d=(f>>2&3)+1;if(b+d>g)throw errors.ended;const h=decodeUInt(a.bytes.subarray(b,b+=d)),c=new Array(h),e=(f&3)+1;if(b+e>g)throw errors.ended;const i=decodeUInt(a.bytes.subarray(b,b+=e));if(a.map.set(a.offset,c),a.cursor+=d+e+1,a.offset+=d+e+1,(f>>4&1)===0){for(let b=0;b<i;b+=1){const d=decodeData(a);d!==errors.hole&&(c[b]=d)}return c}for(let d=0;d<i;d+=1){if(isNaturalByte(a)===!1)throw errors.malformed;const b=decodeData(a);if(b>=h)throw errors.malformed;if(c.hasOwnProperty(b))throw errors.malformed;if(isHoleByte(a))throw errors.malformed;c[b]=decodeData(a)}return c}function decodeTypedArray(a){const d=a.offset,c=a.bytes[a.cursor],b=endian!==(c>>4&1?"BE":"LE"),e=c&15;a.cursor++,a.offset++;try{let f;if(isBufferByte(a)===!1)throw errors.malformed;const c=decodeData(a);switch(e){case 0:f=new DataView(c);break;case 1:f=new Int8Array(c);break;case 2:f=new Uint8Array(c);break;case 3:f=new Uint8ClampedArray(c);break;case 4:f=b?new Int16Array(swap16(c.slice())):new Int16Array(c);break;case 5:f=b?new Uint16Array(swap16(c.slice())):new Uint16Array(c);break;case 6:f=b?new Int32Array(swap32(c.slice())):new Int32Array(c);break;case 7:f=b?new Uint32Array(swap32(c.slice())):new Uint32Array(c);break;case 8:f=b?new Float32Array(swap32(c.slice())):new Float32Array(c);break;case 9:f=b?new Float64Array(swap64(c.slice())):new Float64Array(c);break;case 10:f=b?new BigInt64Array(swap64(c.slice())):new BigInt64Array(c);break;case 11:f=b?new BigUint64Array(swap64(c.slice())):new BigUint64Array(c);break;default:throw errors.malformed}return a.map.set(d,f),f}catch(b){throw b===errors.ended?(a.cursor--,a.offset--,b):b}}function decodeDate(a){const b=a.offset;a.cursor++,a.offset++;try{if(isDateByte(a)===!1)throw errors.malformed;const c=new Date(decodeData(a));return a.map.set(b,c),c}catch(b){throw b===errors.ended?(a.cursor--,a.offset--,b):b}}function decodeRegExp(a){const b=a.offset;a.cursor++,a.offset++;try{if(isStringByte(a)===!1)throw errors.malformed;const c=decodeData(a),d=c.lastIndexOf("/");if(c[0]!=="/"||d<=0)throw errors.malformed;const e=new RegExp(c.slice(1,d),c.slice(d+1));return a.map.set(b,e),e}catch(b){throw b===errors.ended?(a.cursor--,a.offset--,b):b}}function decodeReference(a){a.cursor++,a.offset++;try{if(isNaturalByte(a)===!1)throw errors.malformed;const b=decodeData(a);if(a.map.has(b)===!1)throw errors.malformed;return a.map.get(b)}catch(b){throw b===errors.ended?(a.cursor--,a.offset--,b):b}}function decodeUInt(c){let a=0,b=0;return c.forEach(function(c){a+=c*Math.pow(2,b),b+=8}),a}function decodeBigUInt(d){const a=BigInt(0),e=BigInt(8);let b=a,c=a;return d.forEach(function(a){b+=BigInt(a)<<c,c+=e}),b}function decodeUTF8(a,c,b){try{return new TextDecoder("utf-8").decode(a.subarray(c,b))}catch(f){let d=c,e="";while(d<b){let c;if(a[d]===0)break;if((a[d]&128)===0)e+=String.fromCharCode(a[d++]);else if((a[d]&224)===192&&d+1<b)c=(a[d++]&31)<<6|a[d++]&63,e+=String.fromCharCode(c);else if((a[d]&240)===224&&d+2<b)c=(a[d++]&15)<<12|(a[d++]&63)<<6|a[d++]&63,e+=String.fromCharCode(c);else if((a[d]&248)===240&&d+3<b)if(c=(a[d++]&7)<<18|(a[d++]&63)<<12|(a[d++]&63)<<6|a[d++]&63,c>65535){c-=65536;const a=c>>>10&1023|55296,b=c&1023|56320;e+=String.fromCharCode(a,b)}else e+=String.fromCharCode(c);else break}return e}}function decodeStream(a){let b;if(a===void 0)a={};else if(typeof a!="object")throw new TypeError("The options parameter must be an object.");if(a.hasOwnProperty("maxlength")===!1)b=1073741824;else if(typeof a.maxlength=="number"&&a.maxlength>0)b=a.maxlength;else throw new RangeError("The maxlength option must be a positive integer.");const c=decoder(b),d=new WritableStream(c);return c.stream=d,d}function decodeAsync(b,a){let c;if(a===void 0)a={};else if(typeof a!="object")throw new TypeError("The options parameter must be an object.");if(a.hasOwnProperty("maxlength")===!1)c=1073741824;else if(typeof a.maxlength=="number"&&a.maxlength>0)c=a.maxlength;else throw new RangeError("The maxlength option must be a positive integer.");if(typeof b=="object"){if(b[Symbol.asyncIterator]!==void 0){const d=b[Symbol.asyncIterator](),a=decoder(c);return a.start(),new Promise(function(e,b){d.next().then(c).catch(b);function c(f){f.done===!1?(a.write(f.value),d.next().then(c).catch(b)):e(a.close())}})}if(b.constructor.name==="ReadableStream"){const d=b.getReader(),a=decoder(c);return a.start(),new Promise(function(e,b){d.read().then(c).catch(b);function c(f){f.done===!1?(a.write(f.value),d.read().then(c).catch(b)):e(a.close())}})}throw new TypeError("The readable parameter must be a readable stream or async iterable.")}else throw new TypeError("The readable parameter must be a readable stream or async iterable.")}function decoder(i){const a={},b=[{}],d=Symbol(),e=Symbol(),c=Symbol(),f=Symbol(),h=Symbol(),m=Symbol();return{start:j,close:k,write:l};function j(f){a.map=new Map,a.bytes=new Uint8Array(0),a.cursor=0,a.offset=0,a.length=0,a.method="stream",Object.defineProperty(b[0],e,{configurable:!0,value:1}),Object.defineProperty(b[0],d,{configurable:!0,writable:!0,value:0}),Object.defineProperty(b[0],c,{configurable:!0,writable:!0,value:"root"})}function k(c){if(a.bytes.length>0)if(c!==void 0)c.error(errors.unused);else throw errors.unused;else{const a=b[0].root;if(delete b[0].root,this.stream!==void 0)this.stream.result=a,delete this.stream;else return a}}function l(k,l){let j;if((a.length+=k.length)<=i){a.bytes=concatBytes([a.bytes,k]);const l=a.bytes.length;let i=b.length-1;while(i>=0){const o=b[i],k=n(o);if(k===errors.property)try{if(a.cursor+1>l)break;let e=decodeData(a);if(e!==errors.hole){{if(g(o,e),i===0)break;if(b.pop(),b[i-1][c]===h){if(b[i-1].has(k))throw errors.malformed;b[i-1][c]=e}}}else if(o[f]==="A")o[d]++,b.pop();else throw errors.malformed}catch(b){if(b===errors.collection){{let b=a.cursor;const h=a.bytes[b++];if(h>>5===4){let f;const i=(h&7)+1;if(b+i>l)break;const j=decodeUInt(a.bytes.subarray(b,b+=i));switch(h>>3&3){case 0:f=[];break;case 1:f={};break;case 2:f=new Map;break;case 3:f=new Set;break}Object.defineProperty(f,e,{configurable:!0,value:j}),Object.defineProperty(f,d,{configurable:!0,writable:!0,value:0}),Object.defineProperty(f,c,{configurable:!0,writable:!0,value:void 0}),g(o,f),a.map.set(a.offset,f),a.cursor+=i+1,a.offset+=i+1}else if(h>>5===5){const j=(h>>2&3)+1;if(b+j>l)break;const m=decodeUInt(a.bytes.subarray(b,b+=j)),i=new Array(m),k=(h&3)+1;if(b+k>l)break;const n=decodeUInt(a.bytes.subarray(b,b+=k));Object.defineProperty(i,e,{configurable:!0,value:n}),Object.defineProperty(i,d,{configurable:!0,writable:!0,value:0}),Object.defineProperty(i,c,{configurable:!0,writable:!0,value:void 0}),Object.defineProperty(i,f,{configurable:!0,value:(h>>4&1)===0?"A":"B"}),g(o,i),a.map.set(a.offset,i),a.cursor+=j+k+1,a.offset+=j+k+1}}}else{b!==errors.ended&&(j=b);break}}else if(k[d]<k[e]){const g=k.constructor.name;if(g==="Array")if(k[f]!=="B")k[c]=k[d],b.push(k);else try{if(isNaturalByte(a)===!1)throw errors.malformed;const d=decodeData(a);if(d>=k.length)throw errors.malformed;if(k.hasOwnProperty(d))throw errors.malformed;k[c]=d,b.push(k)}catch(a){a!==errors.ended&&(j=a);break}else if(g==="Object")try{if(isStringByte(a)===!1)throw errors.malformed;const d=decodeData(a);if(k.hasOwnProperty(d))throw errors.malformed;k[c]=d,b.push(k)}catch(a){a!==errors.ended&&(j=a);break}else if(g==="Map"){k[c]=h,b.push(k);const a={};Object.defineProperty(a,e,{configurable:!0,value:1}),Object.defineProperty(a,d,{configurable:!0,writable:!0,value:0}),Object.defineProperty(a,c,{configurable:!0,writable:!1,value:"root"}),b.push(a)}else g==="Set"&&(k[c]=m,b.push(k))}else{if(delete k[f],delete k[c],delete k[d],delete k[e],i===0)break;if(b.pop(),b[i-1][c]===h){if(b[i-1].has(k))throw errors.malformed;b[i-1][c]=k}}i=b.length-1}j===void 0&&(a.bytes=a.bytes.slice(a.cursor),a.cursor=0)}else j=errors.exceeded;if(j!==void 0)if(l!==void 0)l.error(j);else throw j}function g(a,b){const e=a.constructor.name;if(e==="Array")a.hasOwnProperty(f)?(a[a[c]]=b,a[d]++):(a.push(b),a[d]++);else if(e==="Object")a[a[c]]=b,a[d]++;else if(e==="Map")a.set(a[c],b),a[d]++;else if(e==="Set"){if(a.has(b))throw errors.malformed;a.add(b),a[c]=b,a[d]++}}function n(a){const b=a[c],d=a.constructor.name;if(d==="Array"||d==="Object")return a.hasOwnProperty(b)?a[b]:errors.property;if(d==="Map")return a.has(b)?a.get(b):errors.property;if(d==="Set")return a.has(b)?b:errors.property}}function getEndianness(){const a=new ArrayBuffer(2),b=new Uint16Array(a);b[0]=65279;const c=new Uint8Array(a);return c[0]===254?"BE":"LE"}function appendBytes(a,b){a.bytes.push(b),a.length+=b.length}function concatBytes(b,c){let a=0,d=0;c===void 0?b.forEach(function(b){a+=b.length}):a=c;const e=new Uint8Array(a);return b.forEach(function(a){e.set(a,d),d+=a.length}),e}function analyzeArray(g){let c=0,d=0,e=0,f=0,a=-1;g.forEach(function(g,b){a=b,b<=65535?b<=255?c++:d++:b<=1677215?e++:f++}),a+=1;const b=c+d+e+f;if(b===g.length)return{};const h=a-b,i=2*c+3*d+4*e+5*f;return h<=i?{nslot:a}:{nelement:b}}function swap16(b){const a=new Uint8Array(b);for(let b=0,c=a.length;b<c;b+=2){const d=a[b];a[b]=a[b+1],a[b+1]=d}return b}function swap32(b){const a=new Uint8Array(b);for(let b=0,c=a.length;b<c;b+=4)for(let c=0;c<2;c+=1){const d=a[b+c];a[b+c]=a[b+3-c],a[b+3-c]=d}return b}function swap64(b){const a=new Uint8Array(b);for(let b=0,c=a.length;b<c;b+=8)for(let c=0;c<4;c+=1){const d=a[b+c];a[b+c]=a[b+7-c],a[b+7-c]=d}return b}function isNaturalByte(b){const a=b.bytes[b.cursor];if(a===void 0)throw errors.ended;return a>>5===1&&(a>>4&1)===0&&(a>>3&1)===0}function isHoleByte(a){const b=a.bytes[a.cursor];if(b===void 0)throw errors.ended;return b===12}function isStringByte(b){const a=b.bytes[b.cursor];if(a===void 0)throw errors.ended;return a>>5===3&&(a>>3&3)===0}function isBufferByte(b){const a=b.bytes[b.cursor];if(a===void 0)throw errors.ended;return a>>5===3&&(a>>3&3)>=2}function isDateByte(b){const a=b.bytes[b.cursor];if(a===void 0)throw errors.ended;return a>>5===1&&(a>>4&1)===0||a===10}